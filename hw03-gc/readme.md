####Анализ работы различных GC

Общие параметры запуска:
- -Xms128m
- -Xmx128m
- -Xlog:gc=debug:file=./logs/gc-%p-%t.log:tags,uptime,time,level:filecount=5,filesize=10m

Собранные результаты сведены в [таблицу](https://docs.google.com/spreadsheets/d/1U6ozvqiKiTIsyiPYXr1dgzZjHsGWd5wT3nHnwD0FtNI/edit?usp=sharing)

Критерии оценки:
* продолжительность работы, сек - Uptime
* количество выполненных циклов (объем полезной работы) - LoopsCount
* объем полезной работы за единицу времени (чем выше - тем лучше) - LoopsCount/Uptime
* отношение общего времени работы к времени работы GC (чем выше - тем лучше) - Uptime/GCAllDuration

Оценка:
* продолжительность работы - наибольшее у G1, ниаменьшее у ParallelGC
* количество выполненных циклов - наибольшее у G1, ниаменьшее у SerialGC
* объем полезной работы за единицу времени - наибольшее у ParallelGC, ниаменьшее у SerialGC
* отношение общего времени работы к времени работы GC - наибольшее у G1, ниаменьшее у SerialGC

Выводы:
* **G1** - программа выполнила наибольшее количество работы. GC портатил на свою работу наименьшее количество времени с останавкой работы основного приложения. Это связано с тем, что часть своей работы GC выполняет во время работы основного приложения. Выигрывает по большенству показателей. Уступает ParallelGC по производительности.
* **ParallelGC** - наибольшая производительность. По остальным показателям на втором месте. Имеет смысл применять, где важна скорость выполения и имеется несколько процессорных ядер.
* **SerialGC** - проигрывает по всем показателям. Не вижу смысла в его применении при наличии первых двух.








